
package no.uio.medisin.bag.core.mirna;

import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import no.uio.medisin.bag.core.sequence.SimpleSeq;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import static no.uio.medisin.bag.core.sequence.SimpleSeq.NTcount;
import static no.uio.medisin.bag.core.sequence.SimpleSeq.NTcount;

/**
 * Class to parse the sequence and structure of a pri-miRNA, pre-miRNA and miRNA
 * The secondary structure is assumed to be generated by RNAFold, insofar as the
 * structure is defined using Vienna dot bracket notation 
 * @see <a href="http://rna.tbi.univie.ac.at/help.html#A6"> doc bracket notation</a>.
 * If a hairpin structure is present in the predicted structure, it must have 
 * the form:
 *    (((.(((....)))..))
 * i.e, a series of '.' bounded on the left side by a succession of '(' and '.' 
 * and on the right side by a similar number of ')' and '.'
 * This structure is encapsulated by a regular expression which is used to 
 * search the predicted structure for the presence of a hairpin. 
 * 
 * The detailed parsing of the predicted structure is carried out in {@link #parsePrimiRNAStructureString(PriMiRNA priRNA)}
 * 
 * @author weibo and Simon Rayner
 * 
 */
public class CharPriMiRNA {
    
    static Logger logger = LogManager.getRootLogger();    

    private PriMiRNA priRNA;
    private PreMiRNA preRNA;
    private MiRNA miRNA;

    private String priStructLine1;
    private String priStructLine2;
    private String priStructLine3;
    private String priStructLine4;
    
    public static final String PRI_NUMBER_OF_UNPAIRED_BASES_IN_STEM = "PriNumOfUnpairedBases";
    public static final String PRI_NUMBER_OF_BULGES = "PriNumOfBulges";
    public static final String PRI_UNPAIRED_BASE_RATE = "PriUnpairedBaseRate";
    public static final String PRI_NUMBER_OF_PAIRED_BASES = "PriNumOfPairedBases";
    public static final String PRI_NUMBER_OF_GU_PAIRS = "PriNumOfGUPairs";
    public static final String PRI_MIDBASE = "PriMiddleBase";
    
    public static final String PRI_BASAL_SEGMENT_SIZE = "PriBasalSegSize";
    public static final String PRI_BASAL_SEGMENT_END = "PriBasalSegEnd";
    public static final String PRI_BASAL_SEGMENT_NUM = "PriBasalSegNum";
    
    public static final String PRI_TERMINAL_LOOP_SIZE = "PriTerminalLoopSize";
    public static final String PRI_TERMINAL_LOOP_SEQ = "PriTerminalLoopSeq";
    public static final String PRI_TERMINAL_LOOP_START = "PriTerminalLoopStart";
    public static final String PRI_TERMINAL_LOOP_END = "PriTerminalLoopEnd";
    
    public static final String PRI_LARGEST_BULGE = "PriLargestBulge";
    public static final String PRE_LOWERSTEM_SIZE = "PriLowerStemSize";
    public static final String PRE_LOWERSTEM_NUM_UNPAIRED_BASES = "PreNumOfUnpairedBasesInLowerStem";
    public static final String PRE_LOWERSTEM_UNPAIRED_BASE_RATE = "PreUnpairedBaseRateInLowerStem";
    public static final String PRE_LOWERSTEM_NUM_BULGES = "PreNumOfBulgesInLowerStem";
    public static final String PRE_LOWERSTEM_LARGEST_BULGE = "PreLargestBulgeInLowerStem";
    public static final String PRE_UPPERSTEM_SIZE = "PriUpperStemSize";
    public static final String PRE_TOPSTEM_SIZE = "PreTopStemSize";
    
    
    public static final String PRI_TOPSTEM_NUM_UNPAIRED_BASES = "PriNumOfUnpairedBasesInTopStem";
    public static final String PRI_TOPSTEM_NUM_UNPAIRED_BASE_RATE = "PriUnpairedBaseRateInTopStem";
    public static final String PRI_TOPSTEM_NUM_BULGES = "PriNumOfBulgesInTopStem";
    public static final String PRI_TOPSTEM_LARGEST_BULGE = "PriTopStemLargestBulge";
    public static final String PRI_PRETTY_PLOT = "PriPrettyPlot";

    public static final String PRE_NUMBER_OF_GU_PAIRS = "PreNumOfGUPairs";
    public static final String PRE_NUMBER_OF_PAIRED_BASES = "PreNumOfPairedBases";
    public static final String PRE_NUMBER_OF_UNPAIRED_BASES = "PreNumOfUnpairedBases";
    public static final String PRE_UNPAIRED_BASE_RATE = "PreNUnpairedBaseRate";
    public static final String PRE_TERMINAL_LOOP_SIZE = "PreTerminalLoopSize";
    public static final String PRE_NUMBER_OF_UNPAIRED_BASES_IN_STEM = "PreNumOfUnpairedBases";
    public static final String PRE_NUMBER_OF_BULGES = "PreNumOfBulges";
    public static final String PRE_LARGEST_BULGE = "PreLargestBulge";
   
    
    
    
    /*
       The following RegEx is basically comprised of five parts:
            
            (\\.*)                 : 0 or more '.'         : unmatched bases at 5'' end
            (\\([\\.\\(]*\\()      : 0 or more '.' and '(' : 5' paired bases on stem 
            (\\.+)                 : 0 or more '.' and ')' : terminal loop
            (\\)[\\.\\)]*\\))      : 0 or more '.' and ')' : 3' paired bases on stem            
            (\\.*)                 : 0 or more             : unmatched bases at 3' end
            
     */
    private static final String STEMLOOP_REGEX="(\\.*)(\\([\\.\\(]*\\()(\\.+)(\\)[\\.\\)]*\\))(\\.*)";
                                              // (1)........(2).........(3).......(4)..........(5)
    private static final Pattern STEM_LOOP_PATTERN = Pattern.compile(STEMLOOP_REGEX);
    private Matcher stemLoopMatch;

    
    
    public CharPriMiRNA(PriMiRNA pri){
        
        priRNA = pri;
        
    }

    
    
    /**
     * parse features of pri-miRNA
     */
    public void characterize(){

        parsePrimiRNAStructureString(getPriRNA());

        priStructLine1 = getPriRNA().getPriLine1();
        priStructLine2 = getPriRNA().getPriLine2();
        priStructLine3 = getPriRNA().getPriLine3();
        priStructLine4 = getPriRNA().getPriLine4();
        
        //nucleotide content
        /*
        getPriRNA().setGC_content(getPriRNA().GCcontent());
        getPriRNA().setA_content((float)getPriRNA().NTcount('A')/(float)getPriRNA().getLength());
        getPriRNA().setC_content((float)getPriRNA().NTcount('C')/(float)getPriRNA().getLength());
        getPriRNA().setG_content((float)getPriRNA().NTcount('G')/(float)getPriRNA().getLength());
        getPriRNA().setU_content((float)getPriRNA().NTcount('T')/(float)getPriRNA().getLength());
        */
        //priRNA unpaired base do not include basal part and terminalloop
        //getPriRNA().setNumberOfUnpairedBasesInStem(this.countNumberOfUnpairedBasesInStem());
        
        getPriRNA().putFeature(PRI_NUMBER_OF_UNPAIRED_BASES_IN_STEM, Integer.toString(this.countNumberOfUnpairedBasesInStem()));
        getPriRNA().putFeature(CharPriMiRNA.PRI_NUMBER_OF_GU_PAIRS, Integer.toString(CountRNAFoldGUpairsFromPretty(priStructLine2, priStructLine3)));
        getPriRNA().putFeature(CharPriMiRNA.PRI_NUMBER_OF_GU_PAIRS, Integer.toString(pairCount(priStructLine2)));
        
        getPriRNA().putFeature(CharPriMiRNA.PRI_UNPAIRED_BASE_RATE, 
                Float.toString(calcUnpairedRate(Integer.getInteger(getPriRNA().getFeature(CharPriMiRNA.PRI_NUMBER_OF_UNPAIRED_BASES_IN_STEM)), 
                        Integer.getInteger(getPriRNA().getFeature(CharPriMiRNA.PRI_NUMBER_OF_PAIRED_BASES)))));
        
        //priRNA internal loops DO NOT include basal part or the Terminal Loop
        getPriRNA().getFeatureSet().put(CharPriMiRNA.PRI_NUMBER_OF_BULGES, internalLoopCount(priStructLine2));
        getPriRNA().getFeatureSet().put(CharPriMiRNA.PRI_LARGEST_BULGE, findLargestInternalLoopOnStem(priStructLine1, priStructLine4));

        getPriRNA().buildFeatureSet();
        

    }

    
    
    /**
     * generate an miRNA and pre-miRNA from the pri-miRNA based on the given 
     * miRNA start position and length 
     * 

     * @param miRStartPos int miRNA start location, counting from 0
     * @param miRLength int miRNA length
     * 
     */
    public void defineAndCharacterizePreMiPair(int miRStartPos, int miRLength){

        preRNA = new PreMiRNA();
        miRNA = new MiRNA();

        int strand=findmiRNAStrand(getPriRNA(), miRStartPos, miRLength);
        int upperStart=0, upperEnd=0;
        int[] strIndex=getPriRNA().getStrIndex();
        
        String midBase=getPriRNA().getFeature(CharPriMiRNA.PRI_MIDBASE);
        int basalEnd=Integer.getInteger(getPriRNA().getFeature(CharPriMiRNA.PRI_BASAL_SEGMENT_END));//count from 1

        priStructLine1=getPriRNA().getPriLine1();
        priStructLine2=getPriRNA().getPriLine2();
        priStructLine3=getPriRNA().getPriLine3();
        priStructLine4=getPriRNA().getPriLine4();
        String preMiRNAStructLine1;
        String preMiRNAStructLine2;
        String preMiRNAStructLine3;
        String preMiRNAStructLine4;
        //String miRStructLine1;
        //String miRStructLine2;
        //String miRStructLine3;
        //String miRStructLine4;
        String lowerStemStructLine1;
        String lowerStemStructLine2;
        String lowerStemStructLine3;
        String lowerStemStructLine4;
        String topStemStructLine1;
        String topStemStructLine2;
        String topStemStructLine3;
        String topStemStructLine4;
        
        String dangle;

        switch(strand){
            case 5:
                upperStart = strIndex[miRStartPos];//count from 0
                upperEnd = strIndex[miRStartPos + miRLength - 1];//count from 0
                break;
            case 3:
                upperStart = strIndex[miRStartPos + miRLength - 1];
                upperEnd = strIndex[miRStartPos];
                break;
            default:
        }

        // all positions below count from 1

        getPriRNA().putFeature(CharPriMiRNA.PRI_PRETTY_PLOT,generatePrettyPlotShowingMiRNA(getPriRNA(),upperStart,upperEnd, strand));
        

        // set candidate pre-miRNA parameters
        preMiRNAStructLine1 = priStructLine1.substring(upperStart);
        preMiRNAStructLine2 = priStructLine2.substring(upperStart);
        preMiRNAStructLine3 = priStructLine3.substring(upperStart);
        preMiRNAStructLine4 = priStructLine4.substring(upperStart);
        preRNA.setUpperStart(upperStart + 1);
        preRNA.setUpperEnd(upperEnd + 1);
        preRNA.setSeq(PrettyPlot2Seq(preMiRNAStructLine1, preMiRNAStructLine2) + midBase + reverse(PrettyPlot2Seq(preMiRNAStructLine4, preMiRNAStructLine3)));
        //preRNA.setLength(preRNA.getSeq().length());
        preRNA.setAbsStartInQuerySeq(PrettyPlot2Seq(priStructLine1.substring(0, upperStart), priStructLine2.substring(0, upperStart)).length());
        preRNA.setEnergy(calculatePreMFE(getPriRNA().getStructureStr(), preRNA.getSeq(), preRNA.getStartPos()));
        
        /*
        preRNA.setGC_content(preRNA.GCcontent());
        preRNA.setA_content((float)preRNA.NTcount('A')/(float)preRNA.getLength());
        preRNA.setU_content((float)preRNA.NTcount('U')/(float)preRNA.getLength());
        preRNA.setG_content((float)preRNA.NTcount('G')/(float)preRNA.getLength());
        preRNA.setC_content((float)preRNA.NTcount('C')/(float)preRNA.getLength());
*/
        preRNA.putFeature(
                CharPriMiRNA.PRE_NUMBER_OF_GU_PAIRS, 
                Integer.toString(CountRNAFoldGUpairsFromPretty(preMiRNAStructLine2, preMiRNAStructLine3)));

        preRNA.putFeature(CharPriMiRNA.PRE_NUMBER_OF_PAIRED_BASES, 
                Integer.toString(pairCount(preMiRNAStructLine2)));
        
        //preRNA unpaired bases, do not include terminal loop bases
        preRNA.putFeature(CharPriMiRNA.PRE_NUMBER_OF_UNPAIRED_BASES,
                Integer.toString(unpairedCount(preMiRNAStructLine1, preMiRNAStructLine4)   
                        - Integer.getInteger(preRNA.getFeature(CharPriMiRNA.PRE_TERMINAL_LOOP_SIZE)) 
                        - midBase.length())
        );
        preRNA.putFeature(CharPriMiRNA.PRE_UNPAIRED_BASE_RATE,
                Float.toString(calcUnpairedRate(
                        Integer.getInteger(preRNA.getFeature(CharPriMiRNA.PRE_NUMBER_OF_UNPAIRED_BASES)), 
                        Integer.getInteger(preRNA.getFeature(CharPriMiRNA.PRE_NUMBER_OF_PAIRED_BASES)))));
        
        //preRNA internal loop, do not include terminal loop
        preRNA.putFeature(CharPriMiRNA.PRE_NUMBER_OF_BULGES,
                Integer.toString(internalLoopCount(preMiRNAStructLine2)));
        preRNA.putFeature(CharPriMiRNA.PRE_LARGEST_BULGE,
                Integer.toString(findLargestInternalLoopOnStem(preMiRNAStructLine1, preMiRNAStructLine4)));

        
        
        //set lowerStem parameters
        if (basalEnd < upperStart) {
            lowerStemStructLine1 = priStructLine1.substring(basalEnd, upperStart);
            lowerStemStructLine2 = priStructLine2.substring(basalEnd, upperStart);
            lowerStemStructLine3 = priStructLine3.substring(basalEnd, upperStart);
            lowerStemStructLine4 = priStructLine4.substring(basalEnd, upperStart);
            
            preRNA.putFeature(CharPriMiRNA.PRE_LOWERSTEM_SIZE, Integer.toString(upperStart-basalEnd));
            //preRNA.setLowerStemLength(upperStart-basalEnd);
            
            
            preRNA.putFeature(CharPriMiRNA.PRE_LOWERSTEM_SIZE, Integer.toString(upperStart-basalEnd));
            preRNA.putFeature(CharPriMiRNA.PRE_LOWERSTEM_NUM_UNPAIRED_BASES, 
                    Integer.toString(unpairedCount(lowerStemStructLine1, lowerStemStructLine4)));
            //preRNA.setNumOfUnpairedBasesInLowerStem(unpairedCount(lowerStemStructLine1, lowerStemStructLine4));
            preRNA.putFeature(CharPriMiRNA.PRE_LOWERSTEM_UNPAIRED_BASE_RATE, 
                    Float.toString(calcUnpairedRate(
                            Integer.parseInt(preRNA.getFeature(CharPriMiRNA.PRE_LOWERSTEM_NUM_UNPAIRED_BASES)), 
                                    pairCount(lowerStemStructLine2))));
            //preRNA.setFractOfUnpairedBasesInLowerStem(calcUnpairedRate(preRNA.getLowerStemUnpairedBase_num(), pairCount(lowerStemStructLine2)));

            preRNA.putFeature(CharPriMiRNA.PRE_LOWERSTEM_NUM_BULGES, 
                    Integer.toString(internalLoopCount(lowerStemStructLine2)));
            //preRNA.getNumOfInternalLoopsInLowerStem(internalLoopCount(lowerStemStructLine2));
            preRNA.putFeature(CharPriMiRNA.PRE_LOWERSTEM_LARGEST_BULGE, 
                    Integer.toString(findLargestInternalLoopOnStem(lowerStemStructLine1, lowerStemStructLine4)));            
            //preRNA.SetLargestInternalLoopInLowerStem(findLargestInternalLoopOnStem(lowerStemStructLine1, lowerStemStructLine4));
        }

        preRNA.putFeature(CharPriMiRNA.PRE_UPPERSTEM_SIZE, Integer.toString(upperEnd - upperStart + 1));

        
        
        //set topStem parameters
        
        int stemEnd = strIndex[Integer.parseInt(preRNA.getFeature(CharPriMiRNA.PRE_TERMINAL_LOOP_SIZE))-1];//count from 1
        //int stemEnd = strIndex[getPriRNA().getTerminalLoopStart()-1];//count from 1
        if (upperEnd + 1 < stemEnd) {
            topStemStructLine1 = priStructLine1.substring(upperEnd + 1, stemEnd);
            topStemStructLine2 = priStructLine2.substring(upperEnd + 1, stemEnd);
            topStemStructLine3 = priStructLine3.substring(upperEnd + 1, stemEnd);
            topStemStructLine4 = priStructLine4.substring(upperEnd + 1, stemEnd);

            preRNA.putFeature(CharPriMiRNA.PRE_TOPSTEM_SIZE, Integer.toString(stemEnd - upperEnd - 1));
            //preRNA.setTopStemSize(stemEnd - upperEnd - 1);

            preRNA.putFeature(CharPriMiRNA.PRI_TOPSTEM_NUM_UNPAIRED_BASES, Integer.toString(unpairedCount(topStemStructLine1, topStemStructLine4)));
            //preRNA.setNumOfUnpairedBasesInTopStem(unpairedCount(topStemStructLine1, topStemStructLine4));
            //preRNA.setFractOfUnpairedBasesInTopStem(calcUnpairedRate(Integer.parseInt(preRNA.getFeature(CharPriMiRNA.PRI_TOPSTEM_NUM_UNPAIRED_BASES)), pairCount(topStemStructLine2)));
            preRNA.putFeature(CharPriMiRNA.PRI_TOPSTEM_NUM_UNPAIRED_BASE_RATE, 
                    Float.toString(calcUnpairedRate(Integer.parseInt(preRNA.getFeature(CharPriMiRNA.PRI_TOPSTEM_NUM_UNPAIRED_BASES)), 
                            pairCount(topStemStructLine2))));

            //preRNA.setNumOfInternalLoopsInTopStem(internalLoopCount(topStemStructLine2));
            preRNA.putFeature(CharPriMiRNA.PRI_TOPSTEM_NUM_BULGES, 
                    Integer.toString(internalLoopCount(topStemStructLine2)));
            //preRNA.setTopStemInternalLoopSize(findLargestInternalLoopOnStem(topStemStructLine1, topStemStructLine4));
            preRNA.putFeature(CharPriMiRNA.PRI_TOPSTEM_LARGEST_BULGE, 
                    Integer.toString(findLargestInternalLoopOnStem(topStemStructLine1, topStemStructLine4)));
            
        }
        preRNA.buildFeatureSet();


        //set candidate miRNA parameters
        miRNA.setStructLine1(priStructLine1.substring(upperStart, upperEnd + 1));
        miRNA.setStructLine2(priStructLine2.substring(upperStart, upperEnd + 1));
        miRNA.setStructLine3(priStructLine3.substring(upperStart, upperEnd + 1));
        miRNA.setStructLine4(priStructLine4.substring(upperStart, upperEnd + 1));
        
        miRNA.setSeq(getPriRNA().getSeq().substring(miRStartPos, miRStartPos + miRLength));


        miRNA.setStartPos(miRStartPos + 1);
        miRNA.setEndPos(miRStartPos + miRLength);
        miRNA.setAbsStartInQuerySeq(miRStartPos + getPriRNA().getStartPos()); // <- what is this start pos?? position within the full sequence I think
        miRNA.setAbsEndInQuerySeq(miRNA.getStartPos() + miRLength - 1);
        //miRNA.setLength(miRLength);
        miRNA.setStrand(String.valueOf(strand));
        
        //miRNA dangle (SR: I think this can only be up to 2 nt)

        
        miRNA.addFeature("miRNA_id",                  miRNA.getId());
        miRNA.addFeature("miRNA_sequence",            miRNA.getSeq());
        miRNA.addFeature("miRNA_structure",           miRNA.getStructureStr());
        miRNA.addFeature("miRNA_energy",              String.valueOf(miRNA.getEnergy()));
        miRNA.addFeature("miRNA_size",                String.valueOf(miRNA.getLength()));
        miRNA.addFeature("miRNA_GC_content",          String.valueOf(miRNA.GCfraction() ));
        miRNA.addFeature("miRNA_A_content",           String.valueOf(miRNA.Afraction()));
        miRNA.addFeature("miRNA_U_content",           String.valueOf(miRNA.Ufraction()));
        miRNA.addFeature("miRNA_G_content",           String.valueOf(miRNA.Gfraction()));
        miRNA.addFeature("miRNA_C_content",           String.valueOf(miRNA.Cfraction()));
        miRNA.addFeature("miRNA_pair_number",         String.valueOf(miRNA.getLength()-this.unpairedCount(miRNA.getStructLine1(), miRNA.getStructLine4())));
        miRNA.addFeature("miRNA_G-U_number",          String.valueOf(miRNA.CountGUPairsFromPrettyPlot()));
        miRNA.addFeature("miRNA_unpair_number",       String.valueOf(this.unpairedCount(miRNA.getStructLine1(), miRNA.getStructLine4())));
        miRNA.addFeature("miRNA_unpair_rate",         String.valueOf(this.unpairedCount(miRNA.getStructLine1(), miRNA.getStructLine4())/miRNA.getLength()));
                                                                     
        miRNA.addFeature("strand",                    miRNA.getStrand());
        miRNA.addFeature("miStart",                   String.valueOf(miRNA.getStartPos()));
        miRNA.addFeature("miEnd",                     String.valueOf(miRNA.getEndPos()));
        
        
        /* these two features shouldnt be necessary as long as we are clear how we are
         defining the start and the stop. i.e., is the miRNA start the start position
         within the parent sequence, or within the genome
        */
        miRNA.addFeature("miRNA_start",               String.valueOf(miRNA.getMiStart()));
        miRNA.addFeature("miRNA_end",                 String.valueOf(miRNA.getMiEnd()));
        
        
        /**
         * the following should be defined in a Characterizer class as they are
         * somewhat subjective characteristics. e.g., it's questionable whether
         * number of internal loops is a useful parameter as evidence suggests
         * that it is the location of the bulge that is more important
         */
        if (strand == 5) {
            dangle = findDangleSeqFromPretty(priStructLine3.length()-upperStart-1, reverse(priStructLine4), reverse(priStructLine3));
        } else {
            dangle = findDangleSeqFromPretty(upperEnd,priStructLine1, priStructLine2);
        }

        miRNA.setName(getPriRNA().getName());
        miRNA.setID(miRNA.getName() + "_MIR_" + miRNA.getStartPos()
                + "-" + miRNA.getLength());
        miRNA.addFeature("miRNA_internalLoop_number", String.valueOf(internalLoopCount(miRNA.getStructLine2())));
        miRNA.addFeature("miRNA_internalLoop_size",   String.valueOf(
                                                        findLargestInternalLoopOnStem( 
                                                                miRNA.getStructLine1(), miRNA.getStructLine4())));
        miRNA.addFeature("miRNA_stability",           String.valueOf(
                                                        stability(miRNA.getStructLine2(), miRNA.getStructLine3(), strand)));
        miRNA.addFeature("miRNA_firstBase",           String.valueOf(getPriRNA().getSeq().charAt(miRStartPos)));
        miRNA.addFeature("overhang_base1",            String.valueOf(dangle.charAt(0)));
        miRNA.addFeature("overhang_base2",            String.valueOf(dangle.charAt(1)));


        //store product in priRNA
//        preRNA.addProduct(miRNA);
//        priRNA.addProduct(preRNA);
    }


    
    
    
    /**
     * parse the hairpin structure of a pri-miRNA.
     * positions start from 1
     * 
     * @param priRNA the structure string to be parsed out
     * @return boolean returns true if the structure is a hairpin
     * 
     */
    public boolean parsePrimiRNAStructureString(PriMiRNA priRNA){
        
        stemLoopMatch = STEM_LOOP_PATTERN.matcher(priRNA.getStructureStr());

        if (stemLoopMatch.matches()) {
            //priRNA.setBasalSegSize(Math.max(stemLoopMatch.group(1).length(), stemLoopMatch.group(5).length())); // length of overhang on 5' or 3' end
            priRNA.putFeature(CharPriMiRNA.PRI_BASAL_SEGMENT_SIZE, 
                    Integer.toString(Math.max(stemLoopMatch.group(1).length(), stemLoopMatch.group(5).length())));
            
            // this next assignment does nothing, so we don't add entry to feature table
            //priRNA.setBasalSegEnd(priRNA.getBasalSegSize());                                                    //count from 1
            //priRNA.putFeature(CharPriMiRNA.PRI_BASAL_SEGMENT_END, 
            //        Integer.toString(Math.max(stemLoopMatch.group(1).length(), stemLoopMatch.group(5).length())));

            //priRNA.setBasalBaseNum(stemLoopMatch.group(1).length() + stemLoopMatch.group(5).length());          // length after trimming back the overhang from the 5' or 5' end
            priRNA.putFeature(CharPriMiRNA.PRI_BASAL_SEGMENT_END, 
                    Integer.toString(stemLoopMatch.group(1).length() + stemLoopMatch.group(5).length()));

            
            //priRNA.setTerminalLoopSeq(priRNA.getSeq().substring(stemLoopMatch.start(3), stemLoopMatch.end(3)));
            priRNA.putFeature(CharPriMiRNA.PRI_TERMINAL_LOOP_SEQ, 
                    priRNA.getSeq().substring(stemLoopMatch.start(3), stemLoopMatch.end(3)));
            priRNA.putFeature(CharPriMiRNA.PRI_TERMINAL_LOOP_SIZE, 
                    Integer.toString(priRNA.getSeq().substring(
                            stemLoopMatch.start(3), 
                            stemLoopMatch.end(3)).length()));
            //priRNA.setTerminalLoopStart(stemLoopMatch.start(3)+1);//count from 1
            priRNA.putFeature(CharPriMiRNA.PRI_TERMINAL_LOOP_START, 
                    Integer.toString(stemLoopMatch.start(3)+1));
            //priRNA.setTerminalLoopEnd(stemLoopMatch.end(3));//count from 1
            priRNA.putFeature(CharPriMiRNA.PRI_TERMINAL_LOOP_END, 
                    Integer.toString(stemLoopMatch.end(3)));

            // SR: I think these are calculated in order to determine the base in the middle of the terminal loop 
            int end5 = stemLoopMatch.end(2) + (stemLoopMatch.end(3) - stemLoopMatch.start(3)) / 2; //5' end, count from 1
            int start3 = stemLoopMatch.start(4) - (stemLoopMatch.end(3) - stemLoopMatch.start(3)) / 2; //3' start, count from 0
            
            //priRNA.setMiddleBase("");
            if (end5 < start3)
                priRNA.setMiddleBase(priRNA.getSeq().charAt(end5)+"");//top base on the terminal loop
                        //include terminal loop
            priRNA.setSeq5(priRNA.getSeq().substring(0, end5));
            priRNA.setStr5(priRNA.getStructureStr().substring(0, end5));
            priRNA.setSeq3(priRNA.getSeq().substring(start3));
            priRNA.setStr3(priRNA.getStructureStr().substring(start3));

            priRNA.setStrIndex(VienBK2PrettyPlot(priRNA));
            
            return true;
        }
        return false;
    }

    
    
    /**
     * transform bracket-dot notation string structure to Pretty text plot and
     * store index of the bases on the plot
     * 
     * @param priRNA the pri-miRNA to be plotted
     * @return int[] containing (I think) the position information. This doesn't 
     * seem to be used any more.
     * 
     */
    public int[] VienBK2PrettyPlot(PriMiRNA priRNA) {
        
        
        StringBuilder pril1=new StringBuilder();
        StringBuilder pril2=new StringBuilder();
        StringBuilder pril3=new StringBuilder();
        StringBuilder pril4=new StringBuilder();
        String seq5=priRNA.getSeq5();
        String str5=priRNA.getStr5();
        String seq3=reverse(priRNA.getSeq3());
        String str3=reverse(priRNA.getStr3());
        int size=priRNA.getLength();

        
        /*
          input is on four lines. sequence with '.' are on lines 1 and 4
          sequences with '(' and ')' go on lines 2 & 3 respectively.
        */
        int i = 0, j = 0, n = 0;
        int[] index = new int[size];
        while (i < seq5.length() && j < seq3.length()) {
            if (str5.charAt(i) == '.') {
                pril1.append(seq5.charAt(i));
                pril2.append(' ');
                pril3.append(' ');
                index[i] = n;
                i += 1;
                if (str3.charAt(j) == '.') {
                    pril4.append(seq3.charAt(j));
                    index[size - 1 - j] = n;
                    j += 1;
                } else {
                    pril4.append(' ');
                }
            } else {
                pril1.append(' ');
                if (str3.charAt(j) == '.') {
                    pril2.append(' ');
                    pril3.append(' ');
                    pril4.append(seq3.charAt(j));
                    index[size - 1 - j] = n;
                    j += 1;
                } else {
                    pril2.append(seq5.charAt(i));
                    pril3.append(seq3.charAt(j));
                    pril4.append(' ');
                    index[i] = n;
                    index[size - 1 - j] = n;
                    i += 1;
                    j += 1;
                }
            }
            n++;
        }

        priRNA.setPriLine1(pril1.toString());
        priRNA.setPriLine2(pril2.toString());
        priRNA.setPriLine3(pril3.toString());
        priRNA.setPriLine4(pril4.toString());

        return index;
    }

    
    
    /**
     * reverse string
     * 
     * @param strIn String 
     * @return String reverse str
     */
    public String reverse(String strIn) {
        StringBuilder strReversed = new StringBuilder();
        for (int i = strIn.length() - 1; i >= 0; i--) {
            strReversed.append(strIn.charAt(i));
        }
        return strReversed.toString();
    }

    /**
     * transform structure plot to seq
     * @param s1 String  the first line of one side of the plot
     * @param s2 String  the second line of one side of the plot
     * @return String  representing the sequence
     */
    public String PrettyPlot2Seq(String s1, String s2) {
        StringBuilder seq = new StringBuilder();

        for (int i = 0; i < s1.length(); i++) {
            seq.append(s1.charAt(i)).append(s2.charAt(i));
            
        }
        return seq.toString().replace(" ", "");
    }

    
    
    
    /**
     * 
     * count the number of GU-pairs by parsing out pretty plot.
     * This works based on the assumption there can only be G-C and G-U pairing,
     * which is (it seems) an assumption of RNAFold. 
     * There are 4 lines in the pretty plot, but the pairing can only occur in the
     * middle two.
     * 
     * The differences in the C and G counts gives us the number of GU pairs
     * 
     * e.g.
     * 
     *     CCGCCAU
     *     |||||||
     *     GGUGGUG
     * 
     * @param prettyLine2 the upper middle line from the pretty plot
     * @param prettyLine3 the lower middle line from the pretty plot
     * @return int : the number of GU-wobble pairs
     * 
     * 
     * 
     * 
     */
    public int CountRNAFoldGUpairsFromPretty(String prettyLine2, String prettyLine3){
        int n=prettyLine2.length()+prettyLine3.length();
        int nc=n-(SimpleSeq.NTcount(prettyLine2,'C')
                +SimpleSeq.NTcount(prettyLine2,'c')
                +SimpleSeq.NTcount(prettyLine3,'C')
                +SimpleSeq.NTcount(prettyLine3,'c'));
        int ng=n-(SimpleSeq.NTcount(prettyLine2,'G')
                +SimpleSeq.NTcount(prettyLine2,'g')
                +SimpleSeq.NTcount(prettyLine3,'G')
                +SimpleSeq.NTcount(prettyLine3,'g'));
        return nc-ng;
    }

    
    
    /**
     * When counting the number of unpaired bases, it does not include the basal 
     * segment or the terminal loop.
     * 
     * e.g.
     * 
     *       A      UU   G   U             UA  G UA AC    
     *        UCCGGG  GAG UAG AGGUUGUAUGGUU  GA U  C      
     *        ||||||  ||| ||| |||||||||||||  || |  |  C
     *        AGGUUC  UUC AUC UCCAACAUGUCAA  UU A  G      
     *              CU   G   U                 G GG UC    
     * BASAL |  ------ COUNT IN THIS PART ------   | TERMINAL LOOP
     * 
     * 
     * @return int 
     */
    public int countNumberOfUnpairedBasesInStem(){
        return unpairedCount(priStructLine1,priStructLine4) 
                -Integer.parseInt(getPriRNA().getFeature(CharPriMiRNA.PRI_BASAL_SEGMENT_NUM))
                -Integer.parseInt(getPriRNA().getFeature(CharPriMiRNA.PRI_TERMINAL_LOOP_SIZE))
                -getPriRNA().getMiddleBase().length();
        //  - getPriRNA().getBasalBaseNum() 
        //  - (getPriRNA().getTerminalLoopSeq().length() - getPriRNA().getMidBase().length());
    }

    /**
     * calculate the number of paired nucleotides in the defined structure
     * @param  line2 String
     * @return int: the number of pairs
     */
    public int pairCount(String line2){
        return line2.length()-NTcount(line2,' ');
    }

    
    
    /**
     * calculate the number of unpaired bases
     * @param line1 String
     * @param line4 String
     * @return int: the number of unpaired bases
     */
    public int unpairedCount(String line1, String line4){
        return line1.length()-NTcount(line1,' ')+line4.length()-NTcount(line4,' ');
    }

    
    
    
    /**
     * calculate the unpaired rate
     * 
     * @param unpaired int : the number of unpaired bases
     * @param paired int : the number of pairs
     * @return float: the rate of unpaired bases rate
     */
    public float calcUnpairedRate(int unpaired, int paired) {
        int sum = unpaired + paired * 2;
        if (sum == 0) {
            return 0;
        }
        return (float) unpaired / sum;
    }

    /**
     * calculate the internal loop number
     * 
     * @param  line2 String
     * @return int: the number of internal loop number
     * 
     */
    public int internalLoopCount(String line2){
        char[] l=line2.toCharArray();
        int n=0;
        int size=l.length;
        for(int i=0;i<size-1;i++){
            if(l[i]!=' ' && l[i+1]==' '){
                n+=1;
            }
        }
        if(l[size-1]==' '){
            n-=1;
        }
        return n;
    }

    
    
    /**
     * find the largest internal loop (excluding the Terminal Loop) on Stem
     * 
     * @param  line1 String
     * @param  line4 String
     * @return int: the size of the maximal internal loop
     * 
     */
    public int findLargestInternalLoopOnStem(String line1, String line4){
        return Math.max(findLargestInternalLoopOnStemArm(line1), 
                findLargestInternalLoopOnStemArm(line4));
    }
//    public int internalLoopSize(String line1, String line4) {
//        String l1=line1.replaceAll("^\\w+\\s+","").replaceAll("\\s+\\w+$", " ");
//        String l4=line4.replaceAll("^\\w+\\s+"," ").replaceAll("\\s+\\w+$", "");
//        String[] s = (l1 + l4).replaceAll("\\s+", " ").split(" ");
//        int loop = 0;
//        for (int i = 0; i < s.length; i++) {
//            loop = Math.max(loop, s[i].length());
//        }
//        return loop;
//    }
    
    
    
    /**
     * Find the largest internal loop on specified Stem Arm
     * 
     * @param UnpairedTopOrBottomString sequence of unbound nucleotides 
     *                                  (Top or Bottom String from pretty plot)
     * @return 
     */
    private int findLargestInternalLoopOnStemArm(String UnpairedTopOrBottomString){
        
        char[] unpairedArray = UnpairedTopOrBottomString.toCharArray();
        int armLength = unpairedArray.length;
        
        
        int firstBulge=0;
        for(int nt=0;nt<armLength;nt++){
            if(unpairedArray[nt]==' '){
                firstBulge=nt;
                break;
            }
        }
        
        
        int lastBulge=0;
        for(int nt=armLength-1;nt>0;nt--){
            if(unpairedArray[nt]==' '){
                lastBulge=nt;
                break;
            }
        }
        
        
        int maxBulge=0;
        int thisBulge=0;
        for(int nt=firstBulge;nt<lastBulge;nt++){
            if(unpairedArray[nt]==' ' && unpairedArray[nt+1]!=' '){
                thisBulge=1;
            }
            else if(unpairedArray[nt]!=' ' && unpairedArray[nt+1]!=' '){
                thisBulge+=1;
            }
            else if(unpairedArray[nt]!=' ' && unpairedArray[nt+1]==' '){
                if(thisBulge>maxBulge){
                    maxBulge=thisBulge;
                }
            }
        }
        
        return maxBulge;
    }

    
    
    /**
     * determine the strand of the miRNA on primiRNA
     * @param priMiRNA the query pri-miRNA
     * @param miRNAStart : miRNA start position, count from 0
     * @param miRNAsize  : miRNA length
     * 
     * @return strand : int 5, 3, or 0
     */
    public static int findmiRNAStrand(PriMiRNA priMiRNA, int miRNAStart, int miRNAsize){
        if(miRNAStart+miRNAsize<=priMiRNA.getSeq5().length())
            return 5;
        else if(miRNAStart+1>priMiRNA.getSeq5().length() + priMiRNA.getMiddleBase().length() 
          && miRNAStart+miRNAsize<=priMiRNA.getLength())
            return 3;
        else return 0;
    }

    
    
    /**
     * generate the 3' 2nt overhang
     * @param end--miRNA end position
     * @param line1 Pretty plot uppermost line
     * @param line2 Pretty plot upper middle line
     * @return String the dangle sequence
     */
    public String findDangleSeqFromPretty(int end, String line1, String line2) {
        String dangle="";
        int i=1;
        StringBuilder d=new StringBuilder();
        while(dangle.length()<2 && end+i<line1.length()){
//            dangle=dangle+line1.charAt(end+i)+line2.charAt(end+i);
            d.append(line1.charAt(end+i)).append(line2.charAt(end+i));
            dangle=d.toString().replaceAll("\\s+", "");
            i++;
        }
        if(dangle.length()==1)
            dangle+=" ";
        else if(dangle.length()==0)
            dangle="  ";
        return dangle;
    }

    
    
    /**
     * calculate miRNA stability
     * this is based on rate of the number of hydrogen bonds at two sides of miRNA)
     * 
     * @param  line2 String
     * @param  line3 String
     * @param  strand int: the strand of miRNA
     * @return float: the stability of miRNA
     */
    public float stability(String line2, String line3, int strand){
        
        int u=0;
        char[] l2=line2.toCharArray();
        char[] l3=line3.toCharArray();
        for(int i=0;i<4;i++){
            if(l2[i]==' ') continue;
            else if(l2[i]=='c') u+=2;
            else if(l2[i]=='C') u+=2;
            else u+=1;
        }
        for(int i=0;i<4;i++){
            if(l3[i]==' ') continue;
            else if(l3[i]=='c') u+=2;
            else if(l3[i]=='C') u+=2;
            else u+=1;
        }
        int d=0;
        int n2=l2.length;
        int n3=l3.length;
        for(int i=1;i<5;i++){
            if(l2[n2-i]==' ') continue;
            else if(l2[n2-i]=='c') d+=2;
            else if(l2[n2-i]=='C') d+=2;
            else d+=1;
        }
        for(int i=1;i<5;i++){
            if(l3[n3-i]==' ') continue;
            else if(l3[n3-i]=='c') d+=2;
            else if(l3[n3-i]=='C') d+=2;
            else d+=1;
        }
        if (d == 0 || u == 0) {
            return 0;
        }
        if (strand == 5) {
            return (float) u / d;
        } else if (strand == 3) {
            return (float) d / u;
        } else {
            return 0;
        }
    }

    
    
    /**
     * calculate energy of pre-miRNA defined by the start position
     * and pre-miRNA sequence.
     * Because we are trying to predict miRNAs, there may be many pre-miRNAs
     * associated with different miRNA candidates.
     *  
     * @param priStructStr : String - structure of parent pri-miRNA
     * @param preSeq       : String - sequence of this pre-miRNA candidate
     * @param start        : int    - start position of pre-miRNA candidate
     *                                within the parent pri-miRNA
     * @return             : float  - MFE of the pre-miRNA candidate
     * 
     */
    public float calculatePreMFE(String priStructStr, String preSeq, int start) {
        
        int end = start + preSeq.length();
        String preStr = priStructStr.substring(start, end);
        
        return MfeFoldRNA.foldSequence(preSeq, preStr);
    }

    
    
    /**
     * output the pretty plot of the secondary structure of the supplied 
     * pri-miRNA as a String
     * @param priRNA the query pre-miRNA
     * @return String as a printable String
     */
    public static String prettyPlotToString(PriMiRNA priRNA){
        String priLine1=priRNA.getPriLine1();
        String priLine2=priRNA.getPriLine2();
        String priLine3=priRNA.getPriLine3();
        String priLine4=priRNA.getPriLine4();
        StringBuilder sp=new StringBuilder();

        sp.append(priLine1.substring(0, priLine1.length()-1)).append("\n");
        sp.append(priLine2.substring(0, priLine3.length()-1)).append(priLine1.substring(priLine1.length()-1)).append("\n");
        sp.append(priLine2.substring(0, priLine2.length()-1).replaceAll("\\S", "|")).append(priRNA.getMiddleBase()).append("\n");
        sp.append(priLine3.substring(0, priLine3.length()-1)).append(priLine4.substring(priLine4.length()-1)).append("\n");
        sp.append(priLine4.substring(0, priLine4.length()-1));
        
        return sp.toString();
    }

    
    

    /**
     * mark the miRNA on the supplied pri-miRNA
     * pri-miRNA hairpin structure, miRNA region is highlighted by uppercase letter
     * 
     * @param priRNA PriMiRNA
     * @param upperStart int
     * @param upperEnd int
     * @param strand int
     * @return String as a printable String
     */
    public String generatePrettyPlotShowingMiRNA(PriMiRNA priRNA, int upperStart, int upperEnd, int strand){
        StringBuilder structureString=new StringBuilder();
        if(strand==5){
            if(upperEnd+1<priStructLine1.length()-1){
                structureString.append(priStructLine1.substring(0, upperStart).toLowerCase())
                        .append(priStructLine1.substring(upperStart, upperEnd+1).toUpperCase())
                        .append(priStructLine1.substring(upperEnd+1, priStructLine1.length()-1).toLowerCase()).append("\n");
                
                structureString.append(priStructLine2.substring(0, upperStart).toLowerCase())
                        .append(priStructLine2.substring(upperStart, upperEnd+1).toUpperCase())
                        .append(priStructLine2.substring(upperEnd+1, priStructLine2.length()-1).toLowerCase())
                        .append(priStructLine1.substring(priStructLine1.length()-1).toLowerCase()).append("\n");
            }
            structureString.append(priStructLine2.substring(0, priStructLine2.length()-1).replaceAll("\\S", "|"))
                    .append(priRNA.getMiddleBase().toLowerCase()).append("\n");
            structureString.append(priStructLine3.substring(0,priStructLine3.length()-1).toLowerCase())
                    .append(priStructLine4.substring(priStructLine4.length()-1).toLowerCase()).append("\n");
            structureString.append(priStructLine4.substring(0, priStructLine4.length()-1).toLowerCase());

        }
        else{
            structureString.append(priStructLine1.substring(0, priStructLine1.length()-1).toLowerCase()).append("\n");
            structureString.append(priStructLine2.substring(0,priStructLine2.length()-1).toLowerCase())
                    .append(priStructLine1.substring(priStructLine1.length()-1).toLowerCase()).append("\n");
            structureString.append(priStructLine2.substring(0, priStructLine2.length()-1).replaceAll("\\S", "|"))
                    .append(priRNA.getMiddleBase().toLowerCase()).append("\n");
            if(upperEnd+1<priStructLine1.length()-1){
                structureString.append(priStructLine3.substring(0, upperStart).toLowerCase())
                        .append(priStructLine3.substring(upperStart, upperEnd+1).toUpperCase())
                        .append(priStructLine3.substring(upperEnd+1, priStructLine3.length()-1).toLowerCase())
                        .append(priStructLine4.substring(priStructLine4.length()-1).toLowerCase()).append("\n");
                structureString.append(priStructLine4.substring(0, upperStart).toLowerCase())
                        .append(priStructLine4.substring(upperStart, upperEnd+1).toUpperCase())
                        .append(priStructLine4.substring(upperEnd+1, priStructLine4.length()-1).toLowerCase());
            }

        }
        return structureString.toString();
    }

   

    /**
     * gather all the features of a pri-miRNA and its pre-miRNA and miRNA 
     * to store in a HashMap
     * before calling, the miRNA, pre-miRNA and pri-miRNA need to be defined,
     * so this cannot be called on, for example, the pre-miRNA only
     * 
     * @return tripletFeatures HashMap of features
     * 
     */
    public HashMap characterizePriPreMiTriplet(){

        HashMap tripletFeatures=new HashMap();

        tripletFeatures.putAll(getPriRNA().getFeatureSet());
        //tripletFeatures.put("plot", getPriRNA().getPriPlot()); this is now stored in the feature set
        tripletFeatures.putAll(preRNA.getFeatureSet());
        tripletFeatures.putAll(miRNA.getFeatureSet());


        return tripletFeatures;
    }

    /**
     * @return the priRNA
     */
    public PriMiRNA getPriRNA() {
        return priRNA;
    }

    /**
     * @param priRNA the priRNA to set
     */
    public void setPriRNA(PriMiRNA priRNA) {
        this.priRNA = priRNA;
    }


}
